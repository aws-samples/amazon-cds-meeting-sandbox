"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = void 0;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const logging_1 = require("../logging");
const aws_auth_1 = require("./aws-auth");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
/**
 * Perform a hotswap deployment,
 * short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting)).sdk;
    // The current resources of the Stack.
    // We need them to figure out the physical name of a resource in case it wasn't specified by the user.
    // We fetch it lazily, to save a service call, in case all hotswapped resources have their physical names set.
    const listStackResources = new evaluate_cloudformation_template_1.LazyListStackResources(sdk, stackArtifact.stackName);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        template: stackArtifact.template,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        urlSuffix: (region) => sdk.getEndpointSuffix(region),
        listStackResources,
    });
    const currentTemplate = await nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks(stackArtifact, sdk);
    const stackChanges = cfn_diff.diffTemplate(currentTemplate.deployedTemplate, stackArtifact.template);
    const hotswappableChanges = await findAllHotswappableChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStackNames);
    if (!hotswappableChanges) {
        // this means there were changes to the template that cannot be short-circuited
        return undefined;
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs };
}
exports.tryHotswapDeployment = tryHotswapDeployment;
async function findAllHotswappableChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames) {
    // Skip hotswap if there is any change on stack outputs
    if (stackChanges.outputs.differenceCount > 0) {
        return undefined;
    }
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    let foundNonHotswappableChange = false;
    const promises = [];
    const hotswappableResources = new Array();
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk);
            if (!nestedHotswappableResources) {
                return undefined;
            }
            hotswappableResources.push(...nestedHotswappableResources);
            continue;
        }
        const resourceHotswapEvaluation = isCandidateForHotswapping(change);
        if (resourceHotswapEvaluation === common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT) {
            foundNonHotswappableChange = true;
        }
        else if (resourceHotswapEvaluation === common_1.ChangeHotswapImpact.IRRELEVANT) {
            // empty 'if' just for flow-aware typing to kick in...
        }
        else {
            // run isHotswappable* functions lazily to prevent unhandled rejections
            promises.push(() => [
                lambda_functions_1.isHotswappableLambdaFunctionChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                stepfunctions_state_machines_1.isHotswappableStateMachineChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                ecs_services_1.isHotswappableEcsServiceChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                code_build_projects_1.isHotswappableCodeBuildProjectChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                appsync_mapping_templates_1.isHotswappableAppSyncChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
            ]);
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        const hotswapDetectionResults = await Promise.all(detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const hotswapDetectionResults of changesDetectionResults) {
        const perChangeHotswappableResources = new Array();
        for (const result of hotswapDetectionResults) {
            if (typeof result !== 'string') {
                perChangeHotswappableResources.push(result);
            }
        }
        // if we found any hotswappable changes, return now
        if (perChangeHotswappableResources.length > 0) {
            hotswappableResources.push(...perChangeHotswappableResources);
            continue;
        }
        // no hotswappable changes found, so at least one IRRELEVANT means we can ignore this change;
        // otherwise, all answers are REQUIRES_FULL_DEPLOYMENT, so this means we can't hotswap this change,
        // and have to do a full deployment instead
        if (!hotswapDetectionResults.some(hdr => hdr === common_1.ChangeHotswapImpact.IRRELEVANT)) {
            foundNonHotswappableChange = true;
        }
    }
    return foundNonHotswappableChange ? undefined : hotswappableResources;
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, resChange => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, resChange => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk) {
    const nestedStackName = nestedStackNames[logicalId].nestedStackPhysicalName;
    // the stack name could not be found in CFN, so this is a newly created nested stack
    if (!nestedStackName) {
        return undefined;
    }
    const nestedStackParameters = await evaluateCfnTemplate.evaluateCfnExpression(change.newValue?.Properties?.Parameters);
    const evaluateNestedCfnTemplate = evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(new evaluate_cloudformation_template_1.LazyListStackResources(sdk, nestedStackName), change.newValue?.Properties?.NestedTemplate, nestedStackParameters);
    const nestedDiff = cfn_diff.diffTemplate(change.oldValue?.Properties?.NestedTemplate, change.newValue?.Properties?.NestedTemplate);
    return findAllHotswappableChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackNames[logicalId].nestedChildStackNames);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * returns `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if a resource was deleted, or a change that we cannot short-circuit occured.
 * Returns `ChangeHotswapImpact.IRRELEVANT` if a change that does not impact shortcircuiting occured, such as a metadata change.
 */
function isCandidateForHotswapping(change) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.newValue || !change.oldValue) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // a resource has had its type changed
    if (change.newValue.Type !== change.oldValue.Type) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // Ignore Metadata changes
    if (change.newValue.Type === 'AWS::CDK::Metadata') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    return {
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    logging_1.print(`\n${common_1.ICON} hotswapping resources:`);
    return Promise.all(hotswappableChanges.map(hotswapOperation => {
        return applyHotswappableChange(sdk, hotswapOperation);
    }));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    try {
        for (const name of hotswapOperation.resourceNames) {
            logging_1.print(`   ${common_1.ICON} %s`, chalk.bold(name));
        }
        return await hotswapOperation.apply(sdk);
    }
    finally {
        for (const name of hotswapOperation.resourceNames) {
            logging_1.print(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
        }
        sdk.removeCustomUserAgent(customUserAgent);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseURBQXlEO0FBRXpELCtCQUErQjtBQUMvQix3Q0FBbUM7QUFDbkMseUNBQXFEO0FBRXJELHlGQUE0RztBQUM1RyxtRkFBa0Y7QUFDbEYsdUVBQXFGO0FBQ3JGLDZDQUFpSTtBQUNqSSx5REFBd0U7QUFDeEUsaUVBQWdGO0FBQ2hGLDJFQUF5RjtBQUN6Rix5RkFBMEY7QUFDMUYsaUVBQStGO0FBRy9GOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSxvQkFBb0IsQ0FDeEMsV0FBd0IsRUFBRSxXQUFzQyxFQUNoRSxtQkFBd0MsRUFBRSxhQUFnRDtJQUUxRiwyRkFBMkY7SUFDM0YsTUFBTSxXQUFXLEdBQUcsTUFBTSxXQUFXLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BGLDhHQUE4RztJQUM5RyxrR0FBa0c7SUFDbEcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLFdBQVcsQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLGVBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUNqRixzQ0FBc0M7SUFDdEMsc0dBQXNHO0lBQ3RHLDhHQUE4RztJQUM5RyxNQUFNLGtCQUFrQixHQUFHLElBQUkseURBQXNCLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRixNQUFNLG1CQUFtQixHQUFHLElBQUksaUVBQThCLENBQUM7UUFDN0QsUUFBUSxFQUFFLGFBQWEsQ0FBQyxRQUFRO1FBQ2hDLFVBQVUsRUFBRSxXQUFXO1FBQ3ZCLE9BQU8sRUFBRSxXQUFXLENBQUMsT0FBTztRQUM1QixNQUFNLEVBQUUsV0FBVyxDQUFDLE1BQU07UUFDMUIsU0FBUyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsY0FBYyxF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TSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDMUM7WUFBUztRQUNSLEtBQUssTUFBTSxJQUFJLElBQUksZ0JBQWdCLENBQUMsYUFBYSxFQUFFO1lBQ2pELGVBQUssQ0FBQyxHQUFHLGFBQUksUUFBUSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1NBQ3RFO1FBQ0QsR0FBRyxDQUFDLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQzVDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBJU0RLLCBNb2RlLCBTZGtQcm92aWRlciB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsIExhenlMaXN0U3RhY2tSZXNvdXJjZXMgfSBmcm9tICcuL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9hcHBzeW5jLW1hcHBpbmctdGVtcGxhdGVzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQ29kZUJ1aWxkUHJvamVjdENoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9jb2RlLWJ1aWxkLXByb2plY3RzJztcbmltcG9ydCB7IElDT04sIENoYW5nZUhvdHN3YXBJbXBhY3QsIENoYW5nZUhvdHN3YXBSZXN1bHQsIEhvdHN3YXBPcGVyYXRpb24sIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB9IGZyb20gJy4vaG90c3dhcC9jb21tb24nO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2Vjcy1zZXJ2aWNlcyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2xhbWJkYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvczMtYnVja2V0LWRlcGxveW1lbnRzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlU3RhdGVNYWNoaW5lQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL3N0ZXBmdW5jdGlvbnMtc3RhdGUtbWFjaGluZXMnO1xuaW1wb3J0IHsgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MsIE5lc3RlZFN0YWNrTmFtZXMgfSBmcm9tICcuL25lc3RlZC1zdGFjay1oZWxwZXJzJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBob3Rzd2FwIGRlcGxveW1lbnQsXG4gKiBzaG9ydC1jaXJjdWl0aW5nIENsb3VkRm9ybWF0aW9uIGlmIHBvc3NpYmxlLlxuICogSWYgaXQncyBub3QgcG9zc2libGUgdG8gc2hvcnQtY2lyY3VpdCB0aGUgZGVwbG95bWVudFxuICogKGJlY2F1c2UgdGhlIENESyBTdGFjayBjb250YWlucyBjaGFuZ2VzIHRoYXQgY2Fubm90IGJlIGRlcGxveWVkIHdpdGhvdXQgQ2xvdWRGb3JtYXRpb24pLFxuICogcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyeUhvdHN3YXBEZXBsb3ltZW50KFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIGFzc2V0UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICBjbG91ZEZvcm1hdGlvblN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrLCBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIHJlc29sdmUgdGhlIGVudmlyb25tZW50LCBzbyB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGluZ3MgbGlrZSBBV1M6OlJlZ2lvbiBpbiBDRk4gZXhwcmVzc2lvbnNcbiAgY29uc3QgcmVzb2x2ZWRFbnYgPSBhd2FpdCBzZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2tBcnRpZmFjdC5lbnZpcm9ubWVudCk7XG4gIC8vIGNyZWF0ZSBhIG5ldyBTREsgdXNpbmcgdGhlIENMSSBjcmVkZW50aWFscywgYmVjYXVzZSB0aGUgZGVmYXVsdCBvbmUgd2lsbCBub3Qgd29yayBmb3IgbmV3LXN0eWxlIHN5bnRoZXNpcyAtXG4gIC8vIGl0IGFzc3VtZXMgdGhlIGJvb3RzdHJhcCBkZXBsb3kgUm9sZSwgd2hpY2ggZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIHRvIHVwZGF0ZSBMYW1iZGEgZnVuY3Rpb25zXG4gIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChyZXNvbHZlZEVudiwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuICAvLyBUaGUgY3VycmVudCByZXNvdXJjZXMgb2YgdGhlIFN0YWNrLlxuICAvLyBXZSBuZWVkIHRoZW0gdG8gZmlndXJlIG91dCB0aGUgcGh5c2ljYWwgbmFtZSBvZiBhIHJlc291cmNlIGluIGNhc2UgaXQgd2Fzbid0IHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAgLy8gV2UgZmV0Y2ggaXQgbGF6aWx5LCB0byBzYXZlIGEgc2VydmljZSBjYWxsLCBpbiBjYXNlIGFsbCBob3Rzd2FwcGVkIHJlc291cmNlcyBoYXZlIHRoZWlyIHBoeXNpY2FsIG5hbWVzIHNldC5cbiAgY29uc3QgbGlzdFN0YWNrUmVzb3VyY2VzID0gbmV3IExhenlMaXN0U3RhY2tSZXNvdXJjZXMoc2RrLCBzdGFja0FydGlmYWN0LnN0YWNrTmFtZSk7XG4gIGNvbnN0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUgPSBuZXcgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKHtcbiAgICB0ZW1wbGF0ZTogc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSxcbiAgICBwYXJhbWV0ZXJzOiBhc3NldFBhcmFtcyxcbiAgICBhY2NvdW50OiByZXNvbHZlZEVudi5hY2NvdW50LFxuICAgIHJlZ2lvbjogcmVzb2x2ZWRFbnYucmVnaW9uLFxuICAgIHBhcnRpdGlvbjogKGF3YWl0IHNkay5jdXJyZW50QWNjb3VudCgpKS5wYXJ0aXRpb24sXG4gICAgdXJsU3VmZml4OiAocmVnaW9uKSA9PiBzZGsuZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uKSxcbiAgICBsaXN0U3RhY2tSZXNvdXJjZXMsXG4gIH0pO1xuXG4gIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IGxvYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKHN0YWNrQXJ0aWZhY3QsIHNkayk7XG4gIGNvbnN0IHN0YWNrQ2hhbmdlcyA9IGNmbl9kaWZmLmRpZmZUZW1wbGF0ZShjdXJyZW50VGVtcGxhdGUuZGVwbG95ZWRUZW1wbGF0ZSwgc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSk7XG4gIGNvbnN0IGhvdHN3YXBwYWJsZUNoYW5nZXMgPSBhd2FpdCBmaW5kQWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgICBzdGFja0NoYW5nZXMsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIHNkaywgY3VycmVudFRlbXBsYXRlLm5lc3RlZFN0YWNrTmFtZXMsXG4gICk7XG5cbiAgaWYgKCFob3Rzd2FwcGFibGVDaGFuZ2VzKSB7XG4gICAgLy8gdGhpcyBtZWFucyB0aGVyZSB3ZXJlIGNoYW5nZXMgdG8gdGhlIHRlbXBsYXRlIHRoYXQgY2Fubm90IGJlIHNob3J0LWNpcmN1aXRlZFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBhcHBseSB0aGUgc2hvcnQtY2lyY3VpdGFibGUgY2hhbmdlc1xuICBhd2FpdCBhcHBseUFsbEhvdHN3YXBwYWJsZUNoYW5nZXMoc2RrLCBob3Rzd2FwcGFibGVDaGFuZ2VzKTtcblxuICByZXR1cm4geyBub09wOiBob3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCwgc3RhY2tBcm46IGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tJZCwgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmRBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKFxuICBzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZixcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IElTREssXG4gIG5lc3RlZFN0YWNrTmFtZXM6IHsgW25lc3RlZFN0YWNrTmFtZTogc3RyaW5nXTogTmVzdGVkU3RhY2tOYW1lcyB9LFxuKTogUHJvbWlzZTxIb3Rzd2FwT3BlcmF0aW9uW10gfCB1bmRlZmluZWQ+IHtcbiAgLy8gU2tpcCBob3Rzd2FwIGlmIHRoZXJlIGlzIGFueSBjaGFuZ2Ugb24gc3RhY2sgb3V0cHV0c1xuICBpZiAoc3RhY2tDaGFuZ2VzLm91dHB1dHMuZGlmZmVyZW5jZUNvdW50ID4gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCByZXNvdXJjZURpZmZlcmVuY2VzID0gZ2V0U3RhY2tSZXNvdXJjZURpZmZlcmVuY2VzKHN0YWNrQ2hhbmdlcyk7XG5cbiAgbGV0IGZvdW5kTm9uSG90c3dhcHBhYmxlQ2hhbmdlID0gZmFsc2U7XG4gIGNvbnN0IHByb21pc2VzOiBBcnJheTwoKSA9PiBBcnJheTxQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+Pj4gPSBbXTtcbiAgY29uc3QgaG90c3dhcHBhYmxlUmVzb3VyY2VzID0gbmV3IEFycmF5PEhvdHN3YXBPcGVyYXRpb24+KCk7XG5cbiAgLy8gZ2F0aGVyIHRoZSByZXN1bHRzIG9mIHRoZSBkZXRlY3RvciBmdW5jdGlvbnNcbiAgZm9yIChjb25zdCBbbG9naWNhbElkLCBjaGFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKHJlc291cmNlRGlmZmVyZW5jZXMpKSB7XG4gICAgaWYgKGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyAmJiBjaGFuZ2Uub2xkVmFsdWU/LlR5cGUgPT09ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycpIHtcbiAgICAgIGNvbnN0IG5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcyA9IGF3YWl0IGZpbmROZXN0ZWRIb3Rzd2FwcGFibGVDaGFuZ2VzKGxvZ2ljYWxJZCwgY2hhbmdlLCBuZXN0ZWRTdGFja05hbWVzLCBldmFsdWF0ZUNmblRlbXBsYXRlLCBzZGspO1xuICAgICAgaWYgKCFuZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKC4uLm5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uID0gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhjaGFuZ2UpO1xuXG4gICAgaWYgKHJlc291cmNlSG90c3dhcEV2YWx1YXRpb24gPT09IENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UKSB7XG4gICAgICBmb3VuZE5vbkhvdHN3YXBwYWJsZUNoYW5nZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChyZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uID09PSBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQpIHtcbiAgICAgIC8vIGVtcHR5ICdpZicganVzdCBmb3IgZmxvdy1hd2FyZSB0eXBpbmcgdG8ga2ljayBpbi4uLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBydW4gaXNIb3Rzd2FwcGFibGUqIGZ1bmN0aW9ucyBsYXppbHkgdG8gcHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgICAgcHJvbWlzZXMucHVzaCgoKSA9PiBbXG4gICAgICAgIGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UobG9naWNhbElkLCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uLCBldmFsdWF0ZUNmblRlbXBsYXRlKSxcbiAgICAgICAgaXNIb3Rzd2FwcGFibGVTdGF0ZU1hY2hpbmVDaGFuZ2UobG9naWNhbElkLCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uLCBldmFsdWF0ZUNmblRlbXBsYXRlKSxcbiAgICAgICAgaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlKGxvZ2ljYWxJZCwgcmVzb3VyY2VIb3Rzd2FwRXZhbHVhdGlvbiwgZXZhbHVhdGVDZm5UZW1wbGF0ZSksXG4gICAgICAgIGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlKGxvZ2ljYWxJZCwgcmVzb3VyY2VIb3Rzd2FwRXZhbHVhdGlvbiwgZXZhbHVhdGVDZm5UZW1wbGF0ZSksXG4gICAgICAgIGlzSG90c3dhcHBhYmxlQ29kZUJ1aWxkUHJvamVjdENoYW5nZShsb2dpY2FsSWQsIHJlc291cmNlSG90c3dhcEV2YWx1YXRpb24sIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpLFxuICAgICAgICBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UobG9naWNhbElkLCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uLCBldmFsdWF0ZUNmblRlbXBsYXRlKSxcbiAgICAgIF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlc29sdmUgYWxsIGRldGVjdG9yIHJlc3VsdHNcbiAgY29uc3QgY2hhbmdlc0RldGVjdGlvblJlc3VsdHM6IEFycmF5PEFycmF5PENoYW5nZUhvdHN3YXBSZXN1bHQ+PiA9IFtdO1xuICBmb3IgKGNvbnN0IGRldGVjdG9yUmVzdWx0UHJvbWlzZXMgb2YgcHJvbWlzZXMpIHtcbiAgICBjb25zdCBob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGRldGVjdG9yUmVzdWx0UHJvbWlzZXMoKSk7XG4gICAgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMucHVzaChob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzIG9mIGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgY29uc3QgcGVyQ2hhbmdlSG90c3dhcHBhYmxlUmVzb3VyY2VzID0gbmV3IEFycmF5PEhvdHN3YXBPcGVyYXRpb24+KCk7XG5cbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBlckNoYW5nZUhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZm91bmQgYW55IGhvdHN3YXBwYWJsZSBjaGFuZ2VzLCByZXR1cm4gbm93XG4gICAgaWYgKHBlckNoYW5nZUhvdHN3YXBwYWJsZVJlc291cmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5wZXJDaGFuZ2VIb3Rzd2FwcGFibGVSZXNvdXJjZXMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbm8gaG90c3dhcHBhYmxlIGNoYW5nZXMgZm91bmQsIHNvIGF0IGxlYXN0IG9uZSBJUlJFTEVWQU5UIG1lYW5zIHdlIGNhbiBpZ25vcmUgdGhpcyBjaGFuZ2U7XG4gICAgLy8gb3RoZXJ3aXNlLCBhbGwgYW5zd2VycyBhcmUgUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5ULCBzbyB0aGlzIG1lYW5zIHdlIGNhbid0IGhvdHN3YXAgdGhpcyBjaGFuZ2UsXG4gICAgLy8gYW5kIGhhdmUgdG8gZG8gYSBmdWxsIGRlcGxveW1lbnQgaW5zdGVhZFxuICAgIGlmICghaG90c3dhcERldGVjdGlvblJlc3VsdHMuc29tZShoZHIgPT4gaGRyID09PSBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQpKSB7XG4gICAgICBmb3VuZE5vbkhvdHN3YXBwYWJsZUNoYW5nZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvdW5kTm9uSG90c3dhcHBhYmxlQ2hhbmdlID8gdW5kZWZpbmVkIDogaG90c3dhcHBhYmxlUmVzb3VyY2VzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGNoYW5nZXMgdG8gcmVzb3VyY2VzIGluIHRoZSBnaXZlbiBTdGFjay5cbiAqXG4gKiBAcGFyYW0gc3RhY2tDaGFuZ2VzIHRoZSBjb2xsZWN0aW9uIG9mIGFsbCBjaGFuZ2VzIHRvIGEgZ2l2ZW4gU3RhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhY2tSZXNvdXJjZURpZmZlcmVuY2VzKHN0YWNrQ2hhbmdlczogY2ZuX2RpZmYuVGVtcGxhdGVEaWZmKTogeyBbbG9naWNhbElkOiBzdHJpbmddOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UgfSB7XG4gIC8vIHdlIG5lZWQgdG8gY29sbGFwc2UgbG9naWNhbCBJRCByZW5hbWUgY2hhbmdlcyBpbnRvIG9uZSBjaGFuZ2UsXG4gIC8vIGFzIHRoZXkgYXJlIHJlcHJlc2VudGVkIGluIHN0YWNrQ2hhbmdlcyBhcyBhIHBhaXIgb2YgdHdvIGNoYW5nZXM6IG9uZSBhZGRpdGlvbiBhbmQgb25lIHJlbW92YWxcbiAgY29uc3QgYWxsUmVzb3VyY2VDaGFuZ2VzOiB7IFtsb2dJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIH0gPSBzdGFja0NoYW5nZXMucmVzb3VyY2VzLmNoYW5nZXM7XG4gIGNvbnN0IGFsbFJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIHJlc0NoYW5nZSA9PiByZXNDaGFuZ2UuaXNSZW1vdmFsKTtcbiAgY29uc3QgYWxsTm9uUmVtb3ZhbENoYW5nZXMgPSBmaWx0ZXJEaWN0KGFsbFJlc291cmNlQ2hhbmdlcywgcmVzQ2hhbmdlID0+ICFyZXNDaGFuZ2UuaXNSZW1vdmFsKTtcbiAgZm9yIChjb25zdCBbbG9nSWQsIG5vblJlbW92YWxDaGFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKGFsbE5vblJlbW92YWxDaGFuZ2VzKSkge1xuICAgIGlmIChub25SZW1vdmFsQ2hhbmdlLmlzQWRkaXRpb24pIHtcbiAgICAgIGNvbnN0IGFkZENoYW5nZSA9IG5vblJlbW92YWxDaGFuZ2U7XG4gICAgICAvLyBzZWFyY2ggZm9yIGFuIGlkZW50aWNhbCByZW1vdmFsIGNoYW5nZVxuICAgICAgY29uc3QgaWRlbnRpY2FsUmVtb3ZhbENoYW5nZSA9IE9iamVjdC5lbnRyaWVzKGFsbFJlbW92YWxDaGFuZ2VzKS5maW5kKChbXywgcmVtQ2hhbmdlXSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbmdlc0FyZUZvclNhbWVSZXNvdXJjZShyZW1DaGFuZ2UsIGFkZENoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIHdlIGZvdW5kIG9uZSwgdGhlbiB0aGlzIG1lYW5zIHRoaXMgaXMgYSByZW5hbWUgY2hhbmdlXG4gICAgICBpZiAoaWRlbnRpY2FsUmVtb3ZhbENoYW5nZSkge1xuICAgICAgICBjb25zdCBbcmVtb3ZlZExvZ0lkLCByZW1vdmVkUmVzb3VyY2VDaGFuZ2VdID0gaWRlbnRpY2FsUmVtb3ZhbENoYW5nZTtcbiAgICAgICAgYWxsTm9uUmVtb3ZhbENoYW5nZXNbbG9nSWRdID0gbWFrZVJlbmFtZURpZmZlcmVuY2UocmVtb3ZlZFJlc291cmNlQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgICAvLyBkZWxldGUgdGhlIHJlbW92YWwgY2hhbmdlIHRoYXQgZm9ybXMgdGhlIHJlbmFtZSBwYWlyXG4gICAgICAgIGRlbGV0ZSBhbGxSZW1vdmFsQ2hhbmdlc1tyZW1vdmVkTG9nSWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyB0aGUgZmluYWwgcmVzdWx0IGFyZSBhbGwgb2YgdGhlIHJlbWFpbmluZyByZW1vdmFsIGNoYW5nZXMsXG4gIC8vIHBsdXMgYWxsIG9mIHRoZSBub24tcmVtb3ZhbCBjaGFuZ2VzXG4gIC8vICh3ZSBzYXZlZCB0aGUgcmVuYW1lIGNoYW5nZXMgaW4gdGhhdCBvYmplY3QgYWxyZWFkeSlcbiAgcmV0dXJuIHtcbiAgICAuLi5hbGxSZW1vdmFsQ2hhbmdlcyxcbiAgICAuLi5hbGxOb25SZW1vdmFsQ2hhbmdlcyxcbiAgfTtcbn1cblxuLyoqIEZpbHRlcnMgYW4gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYmFzZWQgb24gd2hldGhlciB0aGUgY2FsbGJhY2sgcmV0dXJucyAndHJ1ZScgZm9yIHRoZSBnaXZlbiB2YWx1ZSBpbiB0aGUgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZmlsdGVyRGljdDxUPihkaWN0OiB7IFtrZXk6IHN0cmluZ106IFQgfSwgZnVuYzogKHQ6IFQpID0+IGJvb2xlYW4pOiB7IFtrZXk6IHN0cmluZ106IFQgfSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkaWN0KS5yZWR1Y2UoKGFjYywgW2tleSwgdF0pID0+IHtcbiAgICBpZiAoZnVuYyh0KSkge1xuICAgICAgYWNjW2tleV0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSBhcyB7IFtrZXk6IHN0cmluZ106IFQgfSk7XG59XG5cbi8qKiBGaW5kcyBhbnkgaG90c3dhcHBhYmxlIGNoYW5nZXMgaW4gYWxsIG5lc3RlZCBzdGFja3MuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kTmVzdGVkSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBuZXN0ZWRTdGFja05hbWVzOiB7IFtuZXN0ZWRTdGFja05hbWU6IHN0cmluZ106IE5lc3RlZFN0YWNrTmFtZXMgfSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IElTREssXG4pOiBQcm9taXNlPEhvdHN3YXBPcGVyYXRpb25bXSB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBuZXN0ZWRTdGFja05hbWUgPSBuZXN0ZWRTdGFja05hbWVzW2xvZ2ljYWxJZF0ubmVzdGVkU3RhY2tQaHlzaWNhbE5hbWU7XG4gIC8vIHRoZSBzdGFjayBuYW1lIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBDRk4sIHNvIHRoaXMgaXMgYSBuZXdseSBjcmVhdGVkIG5lc3RlZCBzdGFja1xuICBpZiAoIW5lc3RlZFN0YWNrTmFtZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBuZXN0ZWRTdGFja1BhcmFtZXRlcnMgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/LlBhcmFtZXRlcnMpO1xuICBjb25zdCBldmFsdWF0ZU5lc3RlZENmblRlbXBsYXRlID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5jcmVhdGVOZXN0ZWRFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoXG4gICAgbmV3IExhenlMaXN0U3RhY2tSZXNvdXJjZXMoc2RrLCBuZXN0ZWRTdGFja05hbWUpLCBjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/Lk5lc3RlZFRlbXBsYXRlLCBuZXN0ZWRTdGFja1BhcmFtZXRlcnMsXG4gICk7XG5cbiAgY29uc3QgbmVzdGVkRGlmZiA9IGNmbl9kaWZmLmRpZmZUZW1wbGF0ZShcbiAgICBjaGFuZ2Uub2xkVmFsdWU/LlByb3BlcnRpZXM/Lk5lc3RlZFRlbXBsYXRlLCBjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/Lk5lc3RlZFRlbXBsYXRlLFxuICApO1xuXG4gIHJldHVybiBmaW5kQWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhuZXN0ZWREaWZmLCBldmFsdWF0ZU5lc3RlZENmblRlbXBsYXRlLCBzZGssIG5lc3RlZFN0YWNrTmFtZXNbbG9naWNhbElkXS5uZXN0ZWRDaGlsZFN0YWNrTmFtZXMpO1xufVxuXG4vKiogUmV0dXJucyAndHJ1ZScgaWYgYSBwYWlyIG9mIGNoYW5nZXMgaXMgZm9yIHRoZSBzYW1lIHJlc291cmNlLiAqL1xuZnVuY3Rpb24gY2hhbmdlc0FyZUZvclNhbWVSZXNvdXJjZShvbGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSwgbmV3Q2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIG9sZENoYW5nZS5vbGRSZXNvdXJjZVR5cGUgPT09IG5ld0NoYW5nZS5uZXdSZXNvdXJjZVR5cGUgJiZcbiAgICAgIC8vIHRoaXMgaXNuJ3QgZ3JlYXQsIGJ1dCBJIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gc29tZXRoaW5nIGxpa2UgdW5kZXJzY29yZSBqdXN0IGZvciB0aGlzIGNvbXBhcmlzb25cbiAgICAgIEpTT04uc3RyaW5naWZ5KG9sZENoYW5nZS5vbGRQcm9wZXJ0aWVzKSA9PT0gSlNPTi5zdHJpbmdpZnkobmV3Q2hhbmdlLm5ld1Byb3BlcnRpZXMpO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVuYW1lRGlmZmVyZW5jZShcbiAgcmVtQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIGFkZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuKTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIHtcbiAgcmV0dXJuIG5ldyBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UoXG4gICAgLy8gd2UgaGF2ZSB0byBmaWxsIGluIHRoZSBvbGQgdmFsdWUsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoaXMgd2lsbCBiZSBjbGFzc2lmaWVkIGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VcbiAgICByZW1DaGFuZ2Uub2xkVmFsdWUsXG4gICAgYWRkQ2hhbmdlLm5ld1ZhbHVlLFxuICAgIHtcbiAgICAgIHJlc291cmNlVHlwZToge1xuICAgICAgICBvbGRUeXBlOiByZW1DaGFuZ2Uub2xkUmVzb3VyY2VUeXBlLFxuICAgICAgICBuZXdUeXBlOiBhZGRDaGFuZ2UubmV3UmVzb3VyY2VUeXBlLFxuICAgICAgfSxcbiAgICAgIHByb3BlcnR5RGlmZnM6IChhZGRDaGFuZ2UgYXMgYW55KS5wcm9wZXJ0eURpZmZzLFxuICAgICAgb3RoZXJEaWZmczogKGFkZENoYW5nZSBhcyBhbnkpLm90aGVyRGlmZnMsXG4gICAgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaWYgYSByZXNvdXJjZSB3YXMgZGVsZXRlZCwgb3IgYSBjaGFuZ2UgdGhhdCB3ZSBjYW5ub3Qgc2hvcnQtY2lyY3VpdCBvY2N1cmVkLlxuICogUmV0dXJucyBgQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UYCBpZiBhIGNoYW5nZSB0aGF0IGRvZXMgbm90IGltcGFjdCBzaG9ydGNpcmN1aXRpbmcgb2NjdXJlZCwgc3VjaCBhcyBhIG1ldGFkYXRhIGNoYW5nZS5cbiAqL1xuZnVuY3Rpb24gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSk6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB8IENoYW5nZUhvdHN3YXBJbXBhY3Qge1xuICAvLyBhIHJlc291cmNlIGhhcyBiZWVuIHJlbW92ZWQgT1IgYSByZXNvdXJjZSBoYXMgYmVlbiBhZGRlZDsgd2UgY2FuJ3Qgc2hvcnQtY2lyY3VpdCB0aGF0IGNoYW5nZVxuICBpZiAoIWNoYW5nZS5uZXdWYWx1ZSB8fCAhY2hhbmdlLm9sZFZhbHVlKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgLy8gYSByZXNvdXJjZSBoYXMgaGFkIGl0cyB0eXBlIGNoYW5nZWRcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlICE9PSBjaGFuZ2Uub2xkVmFsdWUuVHlwZSkge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIC8vIElnbm9yZSBNZXRhZGF0YSBjaGFuZ2VzXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSA9PT0gJ0FXUzo6Q0RLOjpNZXRhZGF0YScpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdWYWx1ZTogY2hhbmdlLm5ld1ZhbHVlLFxuICAgIHByb3BlcnR5VXBkYXRlczogY2hhbmdlLnByb3BlcnR5VXBkYXRlcyxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHNkazogSVNESywgaG90c3dhcHBhYmxlQ2hhbmdlczogSG90c3dhcE9wZXJhdGlvbltdKTogUHJvbWlzZTx2b2lkW10+IHtcbiAgcHJpbnQoYFxcbiR7SUNPTn0gaG90c3dhcHBpbmcgcmVzb3VyY2VzOmApO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoaG90c3dhcHBhYmxlQ2hhbmdlcy5tYXAoaG90c3dhcE9wZXJhdGlvbiA9PiB7XG4gICAgcmV0dXJuIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkaywgaG90c3dhcE9wZXJhdGlvbik7XG4gIH0pKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlIb3Rzd2FwcGFibGVDaGFuZ2Uoc2RrOiBJU0RLLCBob3Rzd2FwT3BlcmF0aW9uOiBIb3Rzd2FwT3BlcmF0aW9uKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gbm90ZSB0aGUgdHlwZSBvZiBzZXJ2aWNlIHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBob3Rzd2FwcGVkIGluIHRoZSBVc2VyLUFnZW50XG4gIGNvbnN0IGN1c3RvbVVzZXJBZ2VudCA9IGBjZGstaG90c3dhcC9zdWNjZXNzLSR7aG90c3dhcE9wZXJhdGlvbi5zZXJ2aWNlfWA7XG4gIHNkay5hcHBlbmRDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcblxuICB0cnkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBob3Rzd2FwT3BlcmF0aW9uLnJlc291cmNlTmFtZXMpIHtcbiAgICAgIHByaW50KGAgICAke0lDT059ICVzYCwgY2hhbGsuYm9sZChuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBob3Rzd2FwT3BlcmF0aW9uLmFwcGx5KHNkayk7XG4gIH0gZmluYWxseSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGhvdHN3YXBPcGVyYXRpb24ucmVzb3VyY2VOYW1lcykge1xuICAgICAgcHJpbnQoYCR7SUNPTn0gJXMgJXNgLCBjaGFsay5ib2xkKG5hbWUpLCBjaGFsay5ncmVlbignaG90c3dhcHBlZCEnKSk7XG4gICAgfVxuICAgIHNkay5yZW1vdmVDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcbiAgfVxufVxuIl19